#! /bin/sh
empty_file=""
arg_pp="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/empty"
arg_pp_main="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/arg-pp-main"
arg_source="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/arg-source"
buildcmd="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/buildcmd"
cache="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/cache"
cache_body="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/cache-body"
cleanup="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/empty"
cmd_sink="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/cmd-sink"
logic="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/logic"
reorderlibs="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/reorderlibs"
shell_lib="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/shell-lib"
scan="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/scan"
transform="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/transform-gcc"
transform_sed=" -f /source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/transform.sed"
wrapper_subr_sh="/source/build/hpkgsrc/math/muparser/work/.wrapper/tmp/wrapper-subr.sh"
wrapper_abi=""		# see ABI in mk/defaults/mk.conf
wrapper_type="CXX"	# one of AS, CC, CXX, FC, IMAKE, LD, LIBTOOL.
wrapperlog="${WRAPPER_LOG-/source/build/hpkgsrc/math/muparser/work/.work.log}"
skip_transform="${WRAPPER_SKIP_TRANSFORM-no}"
debug="${WRAPPER_DEBUG-no}"
cat="/bin/cat"
echo="echo"
expr="/bin/expr"
mv="/bin/mv"
sed="/boot/common/bin/sed"
test="test"
Xsed="$sed -e 1s/^X//"
. $shell_lib
. "$wrapper_subr_sh"
updatecache=${WRAPPER_UPDATE_CACHE-yes}
reorder=${WRAPPER_REORDER-no}
case $debug in
yes)	debug_log="msg_log" ;;
*)	debug_log=":" ;;
esac
qcmd="$0"; for arg in ${1+"$@"}; do shquote "$arg"; qcmd="$qcmd $shquoted"; done
msg_log "$wrapperlog" "[*] $0 $qcmd"
cmd="/source/build/hpkgsrc/math/muparser/work/.gcc/bin/g++"
case "$*" in
--wrappee-name) $echo $cmd ; exit ;;
esac
libs=""
rellpath=""
do_transform=yes
init_queue argbuf
init_queue cmdbuf
append_extra_args=yes
. $scan
case $append_extra_args in
yes)
	$debug_log $wrapperlog "    (wrapper.sh) append args: -I/source/build/hpkgsrc/math/muparser/work/.buildlink/include -L/source/build/hpkgsrc/math/muparser/work/.buildlink/lib"
	set -- "$@" -I/source/build/hpkgsrc/math/muparser/work/.buildlink/include -L/source/build/hpkgsrc/math/muparser/work/.buildlink/lib
	;;
*)
	;;
esac
. $arg_source
. $logic
. $cmd_sink
case $reorder in
yes)
	if $test -n "$libs"; then
		. $reorderlibs
	fi
	;;
esac
cmd="$cmd $libs"
PATH="/source/build/hpkgsrc/math/muparser/work/.buildlink/bin:/source/build/hpkgsrc/math/muparser/work/.gcc/bin:/source/build/hpkgsrc/math/muparser/work/.tools/bin:/boot/common/pkg/bin:.:/boot/common/pkg/bin:/boot/home/config/bin:/boot/common/bin:/bin:/boot/apps:/boot/preferences:/boot/system/apps:/boot/system/preferences:/boot/develop/tools/gnupro/bin"; export PATH
msg_log $wrapperlog "<.>" "$cmd"
if [ "${empty_file}" = "${cleanup}" ] && [ "$debug" != "yes" ]; then
	eval "exec $cmd"
	wrapper_results=$?
else
	wrapper_result=0
	eval "$cmd" || wrapper_result="$?"
fi
. $cleanup
[ $wrapper_result -eq 0 ] || [ "$debug" != "yes" ] || {
	echo ""
	echo "[wrapper.sh] note: The real command line, after the pkgsrc wrapper, was:"
	echo "$cmd"
} 1>&2
exit ${wrapper_result}
